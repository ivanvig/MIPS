* Implementacion del MIPS
** Intrucciones implementadas
*** Tipo R

| Instruccion | Descripcion                                                                                                                       | Codigo                                  |   | 2nd LUT | Branch | BEQ/BNE | JRS | JINM | RA | SHAMT |   |  ALU | B/I | S/U |   | RE | WE | S/U | DATA_SIZE |   | REG_WE | MEM/ALU | DATA/PC |
|-------------+-----------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------+---+---------+--------+---------+-----+------+----+-------+---+------+-----+-----+---+----+----+-----+-----------+---+--------+---------+---------|
| SLL         | Shiftea hacia la izquierda un registro (T) una cantidad listada en la instruccion (H) y lo almacena en otro registro (D)          | 0000_00SS_SSST_TTTT_DDDD_DHHH_HH00_0000 |   |       1 |      0 |       0 |   0 |    0 |  0 |     1 |   | 0111 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| SRL         | Shiftea hacia la derecha un registro (T) una cantidad listada en la instruccion (H) y lo almacena en otro registro (D)            | 0000_00SS_SSST_TTTT_DDDD_DHHH_HH00_0010 |   |       1 |      0 |       0 |   0 |    0 |  0 |     1 |   | 0110 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| SRA         | Shiftea aritmetico hacia la derecha un registro (T) una cantidad listada en la instruccion (H) y lo almacena en otro registro (D) | 0000_00SS_SSST_TTTT_DDDD_DHHH_HH00_0011 |   |       1 |      0 |       0 |   0 |    0 |  0 |     1 |   | 1000 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| SLLV        | Shiftea hacia la izquierda un registro (T) una cantidad que esta en otro registro (S) y lo almacena en otro registro (D)          | 0000_00SS_SSST_TTTT_DDDD_DHHH_HH00_0100 |   |       1 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0111 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| SRLV        | Shiftea hacia la derecha un registro (T) una cantidad que esta en otro registro (S) y lo almacena en otro registro (D)            | 0000_00SS_SSST_TTTT_DDDD_DHHH_HH00_0110 |   |       1 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0110 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| SRAV        | Shiftea aritmetico hacia la derecha un registro (T) una cantidad que esta en otro registro (S) y lo almacena en otro registro (D) | 0000_00SS_SSST_TTTT_DDDD_DHHH_HH00_0111 |   |       1 |      0 |       0 |   0 |    0 |  0 |     0 |   | 1000 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| ADDU        | Add unsigned, suma dos registros y almacena el resultado en un registro                                                           | 0000_00SS_SSST_TTTT_DDDD_D000_0010_0001 |   |       1 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0000 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| SUBU        | Substract unsigned, resta dos registros y almacena el resultado en un registro                                                    | 0000_00SS_SSST_TTTT_DDDD_D000_0010_0011 |   |       1 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0001 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| AND         | Bitwise AND dos registros y almacena el resultado en un registro                                                                  | 0000_00SS_SSST_TTTT_DDDD_D000_0010_0100 |   |       1 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0010 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| OR          | Bitwise OR dos registros y almacena el resultado en un registro                                                                   | 0000_00SS_SSST_TTTT_DDDD_D000_0010_0101 |   |       1 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0011 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| XOR         | Bitwise XOR dos registros y almacena el resultado en un registro                                                                  | 0000_00SS_SSST_TTTT_DDDD_D000_0010_0110 |   |       1 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0100 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| NOR         | Bitwise NOR dos registros y almacena el resultado en un registro                                                                  | 0000_00SS_SSST_TTTT_DDDD_D000_0010_0111 |   |       1 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0101 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| SLT         | Si S < T setea D a 1 else 0                                                                                                       | 0000_00SS_SSST_TTTT_DDDD_D000_0010_1010 |   |       1 |      0 |       0 |   0 |    0 |  0 |     0 |   | 1010 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| JR          | Jumpea a la addr del registro S                                                                                                   | 0000_00SS_SSST_TTTT_DDDD_D000_0000_1000 |   |       1 |      0 |       0 |   1 |    0 |  0 |     0 |   | 0000 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      0 |       0 |       0 |
| JALR        | Jumpea a la addr del registro S y guarda PC + 4 en D                                                                              | 0000_00SS_SSST_TTTT_DDDD_D000_0000_1001 |   |       1 |      0 |       0 |   1 |    0 |  0 |     0 |   | 0000 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       0 |       1 |

*** Tipo I

| Instruccion | Descripcion                                                                                | Codigo                                  |   | 2nd LUT | Branch | BEQ/BNE | JRS | JINM | RA | SHAMT |   |  ALU | B/I | S/U |   | RE | WE | S/U | DATA_SIZE |   | REG_WE | MEM/ALU | DATA/PC |
|-------------+--------------------------------------------------------------------------------------------+-----------------------------------------+---+---------+--------+---------+-----+------+----+-------+---+------+-----+-----+---+----+----+-----+-----------+---+--------+---------+---------|
| LB          | Load byte, carga un byte a un registro (T) desde MEM(S + I)                                | 1000_00SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0000 |   1 |   0 |   |  1 |  0 |   0 |        00 |   |      1 |       0 |       0 |
| LH          | Load half word, carga half word a un registro (T) desde MEM(S + I)                         | 1000_01SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0000 |   1 |   0 |   |  1 |  0 |   0 |        01 |   |      1 |       0 |       0 |
| LW          | Load word, carga word a un registro (T) desde MEM(S + I)                                   | 1000_11SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0000 |   1 |   0 |   |  1 |  0 |   0 |        10 |   |      1 |       0 |       0 |
| LBU         | Load byte unsigned, carga unsigned byte a un registro (T) desde MEM(S + I)                 | 1001_00SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0000 |   1 |   0 |   |  1 |  0 |   1 |        00 |   |      1 |       0 |       0 |
| LHU         | Load half word unsigned, carga unsigned half word a un registro (T) desde MEM(S + I)       | 1001_01SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0000 |   1 |   0 |   |  1 |  0 |   1 |        01 |   |      1 |       0 |       0 |
| LWU         | Load word unsigned, carga unsigned word a un registro (T) desde MEM(S + I)                 | 1001_11SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0000 |   1 |   0 |   |  1 |  0 |   1 |        10 |   |      1 |       0 |       0 |
| SB          | Store byte, carga el byte menos significativo desde un registro (T) a MEM(S + I)           | 1010_00SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0000 |   1 |   0 |   |  0 |  1 |   0 |        00 |   |      0 |       0 |       0 |
| SH          | Store half word, carga el half word menos significativo desde un registro (T) a MEM(S + I) | 1010_01SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0000 |   1 |   0 |   |  0 |  1 |   0 |        01 |   |      0 |       0 |       0 |
| SW          | Store word, carga el word desde un registro (T) a MEM(S + I)                               | 1010_11SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0000 |   1 |   0 |   |  0 |  1 |   0 |        10 |   |      0 |       0 |       0 |
| ADDI        | Suma un registro (S) con el inmediato (I) y lo guarda en otro registro (T)                 | 0010_01SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0000 |   1 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| ANDI        | Bitwise AND un registro (S) con el inmediato (I) y lo guarda en otro registro (T)          | 0011_00SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0010 |   1 |   1 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| ORI         | Bitwise OR un registro (S) con el inmediato (I) y lo guarda en otro registro (T)           | 0011_01SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0011 |   1 |   1 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| XORI        | Bitwise XOR un registro (S) con el inmediato (I) y lo guarda en otro registro (T)          | 0011_10SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 0100 |   1 |   1 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| LUI         | El valor inmediato (I) es shifteado a la izquierda 16 bits y guardado en el registro (T)   | 0011_11SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 1011 |   1 |   1 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| SLTI        | If S < I => T = 1, else T = 0                                                              | 0010_10SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    0 |  0 |     0 |   | 1010 |   1 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       1 |       0 |
| BEQ         | Branchea a PC + I*4 si ambos registros (S y T) equalean                                    | 0001_00SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      1 |       0 |   0 |    0 |  0 |     0 |   | 0000 |   1 |   0 |   |  0 |  0 |   0 |        00 |   |      0 |       0 |       0 |
| BNE         | Branchea a PC + I*4 si ambos registros (S y T) no equalean                                 | 0001_01SS_SSST_TTTT_IIII_IIII_IIII_IIII |   |       0 |      1 |       1 |   0 |    0 |  0 |     0 |   | 0000 |   1 |   0 |   |  0 |  0 |   0 |        00 |   |      0 |       0 |       0 |
  
*** Tipo J

| Instruccion | Descripcion                                                                                                          | Codigo                                  |   | 2nd LUT | Branch | BEQ/BNE | JRS | JINM | RA | SHAMT |   |  ALU | B/I | S/U |   | RE | WE | S/U | DATA_SIZE |   | REG_WE | MEM/ALU | DATA/PC |
|-------------+----------------------------------------------------------------------------------------------------------------------+-----------------------------------------+---+---------+--------+---------+-----+------+----+-------+---+------+-----+-----+---+----+----+-----+-----------+---+--------+---------+---------|
| J           | PC = (PC & 0xF0000000) OR (I << 2)                                                                                   | 0000_10II_IIII_IIII_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    1 |  0 |     0 |   | 0000 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      0 |       0 |       0 |
| JAL         | Jumpea a la direccion calculada [PC = (PC & 0xF0000000) OR (I << 2)] y storea la direccion de retorno en RA = PC + 4 | 0000_11II_IIII_IIII_IIII_IIII_IIII_IIII |   |       0 |      0 |       0 |   0 |    1 |  1 |     0 |   | 0000 |   0 |   0 |   |  0 |  0 |   0 |        00 |   |      1 |       0 |       1 |

** Señales de control                                                                                                                                                               

*** DEC
    - RA
    - SHAMT

*** EX                                                                                                                                                                              
                                                                                                                                                                                    
    - ALU [4bits]                                                                                                                                                                   
    	+ 0000 -> ADD                                                                                                                                                                 
    	+ 0001 -> SUB                                                                                                                                                                 
    	+ 0010 -> AND                                                                                                                                                                 
    	+ 0011 -> OR                                                                                                                                                                  
    	+ 0100 -> XOR                                                                                                                                                                 
    	+ 0101 -> NOR                                                                                                                                                                 
    	+ 0110 -> SRL                                                                                                                                                                 
    	+ 0111 -> SLL                                                                                                                                                                 
    	+ 1000 -> SRA                                                                                                                                                                 
    	+ 1001 -> SLA                                                                                                                                                                 
    	+ 1010 -> SLT                                                                                                                                                                 
    	+ 1011 -> LUI
    - B/I
    - S/U

*** MEM
    
    - RE
    - WE
    - S/U
    - DATA_SIZE [2bits]
      + 00 -> byte
      + 01 -> half-word
      + 10 -> word
      + 11 -> NO!

*** WB

    - REG_WE
    - MEM/ALU
    - DATA/PC

** Estructura de bits de control
 
***  EX (7 bits)
   |6        |2    |1    |0      |
   | ALUCTRL | B/I | S/U | SHAMT |
   
*** MEM (5 bits)
   |4	  |3	 |2    |1			 |
   | RE | WE | S/U | DSIZE |
   
*** WB (8 bits)
   |7		  |2			 |1				 |0				 |
   | DEST | REG_WE | MEM/ALU | DATA/PC |



