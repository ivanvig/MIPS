* Implementacion del MIPS
** Intrucciones implementadas
*** Tipo R

| Instruccion | Descripcion                                                                                                                       | Codigo                                  |  ALU | B/I | RE | WE | DATA_SIZE | S/U | DEST  | MEM/ALU | REG_WE |
|-------------+-----------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------+------+-----+----+----+-----------+-----+-------+---------+--------|
| SLL         | Shiftea hacia la izquierda un registro (T) una cantidad listada en la instruccion (H) y lo almacena en otro registro (D)          | 0000_00SS_SSST_TTTT_DDDD_DHHH_HH00_0000 | 0110 |   0 |  0 |  0 |        00 |   0 | DDDDD |       1 |      1 |
| SRL         | Shiftea hacia la derecha un registro (T) una cantidad listada en la instruccion (H) y lo almacena en otro registro (D)            | 0000_00SS_SSST_TTTT_DDDD_DHHH_HH00_0010 | 0110 |   0 |  0 |  0 |        00 |   0 | DDDDD |       1 |      1 |
| SRA         | Shiftea aritmetico hacia la derecha un registro (T) una cantidad listada en la instruccion (H) y lo almacena en otro registro (D) | 0000_00SS_SSST_TTTT_DDDD_DHHH_HH00_0011 | 0111 |   0 |  0 |  0 |        00 |   0 | DDDDD |       1 |      1 |
| SLLV        | Shiftea hacia la izquierda un registro (T) una cantidad que esta en otro registro (S) y lo almacena en otro registro (D)          | 0000_00SS_SSST_TTTT_DDDD_DHHH_HH00_0100 | 0110 |   0 |  0 |  0 |        00 |   0 | DDDDD |       1 |      1 |
| SRLV        | Shiftea hacia la derecha un registro (T) una cantidad que esta en otro registro (S) y lo almacena en otro registro (D)            | 0000_00SS_SSST_TTTT_DDDD_DHHH_HH00_0110 | 0110 |   0 |  0 |  0 |        00 |   0 | DDDDD |       1 |      1 |
| SRAV        | Shiftea aritmetico hacia la derecha un registro (T) una cantidad que esta en otro registro (S) y lo almacena en otro registro (D) | 0000_00SS_SSST_TTTT_DDDD_DHHH_HH00_0111 | 0110 |   0 |  0 |  0 |        00 |   0 | DDDDD |       1 |      1 |
| ADDU        | Add unsigned, suma dos registros y almacena el resultado en un registro                                                           | 0000_00SS_SSST_TTTT_DDDD_D000_0010_0001 | 0000 |   0 |  0 |  0 |        00 |   0 | DDDDD |       1 |      1 |
| SUBU        | Substract unsigned, resta dos registros y almacena el resultado en un registro                                                    | 0000_00SS_SSST_TTTT_DDDD_D000_0010_0011 | 0001 |   0 |  0 |  0 |        00 |   0 | DDDDD |       1 |      1 |
| AND         | Bitwise AND dos registros y almacena el resultado en un registro                                                                  | 0000_00SS_SSST_TTTT_DDDD_D000_0010_0100 | 0010 |   0 |  0 |  0 |        00 |   0 | DDDDD |       1 |      1 |
| OR          | Bitwise OR dos registros y almacena el resultado en un registro                                                                   | 0000_00SS_SSST_TTTT_DDDD_D000_0010_0101 | 0011 |   0 |  0 |  0 |        00 |   0 | DDDDD |       1 |      1 |
| XOR         | Bitwise XOR dos registros y almacena el resultado en un registro                                                                  | 0000_00SS_SSST_TTTT_DDDD_D000_0010_0110 | 0100 |   0 |  0 |  0 |        00 |   0 | DDDDD |       1 |      1 |
| NOR         | Bitwise NOR dos registros y almacena el resultado en un registro                                                                  | 0000_00SS_SSST_TTTT_DDDD_D000_0010_0111 | 0101 |   0 |  0 |  0 |        00 |   0 | DDDDD |       1 |      1 |
| SLT         | Si S < T setea D a 1 else 0                                                                                                       | 0000_00SS_SSST_TTTT_DDDD_D000_0010_1010 | 1000 |   0 |  0 |  0 |        00 |   0 | DDDDD |       1 |      1 |
| JR          | Jumpea a la addr del registro S                                                                                                   | 0000_00SS_SSST_TTTT_DDDD_D000_0000_1000 | 0000 |   0 |  0 |  0 |        00 |   0 | DDDDD |       1 |      1 |
| JALR        | Jumpea a la addr del registro S y guarda PC + 4 en D                                                                              | 0000_00SS_SSST_TTTT_DDDD_D000_0000_1001 | 0000 |   0 |  0 |  0 |           |     | DDDDD |         |        |

*** Tipo I

| Instruccion | Descripcion                                                                                | Codigo                                  | Señales |
|-------------+--------------------------------------------------------------------------------------------+-----------------------------------------+---------|
| LB          | Load byte, carga un byte a un registro (T) desde MEM(S + I)                                | 1000_00SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| LH          | Load half word, carga half word a un registro (T) desde MEM(S + I)                         | 1000_01SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| LW          | Load word, carga word a un registro (T) desde MEM(S + I)                                   | 1000_11SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| LBU         | Load byte unsigned, carga unsigned byte a un registro (T) desde MEM(S + I)                 | 1001_00SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| LHU         | Load half word unsigned, carga unsigned half word a un registro (T) desde MEM(S + I)       | 1001_01SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| LWU         | Load word unsigned, carga unsigned word a un registro (T) desde MEM(S + I)                 | 1001_11SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| SB          | Store byte, carga el byte menos significativo desde un registro (T) a MEM(S + I)           | 1010_00SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| SH          | Store half word, carga el half word menos significativo desde un registro (T) a MEM(S + I) | 1010_01SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| SW          | Store word, carga el word desde un registro (T) a MEM(S + I)                               | 1010_11SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| ADDI        | Suma un registro (S) con el inmediato (I) y lo guarda en otro registro (T)                 | 0010_01SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| ANDI        | Bitwise AND un registro (S) con el inmediato (I) y lo guarda en otro registro (T)          | 0011_00SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| ORI         | Bitwise OR un registro (S) con el inmediato (I) y lo guarda en otro registro (T)           | 0011_01SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| XORI        | Bitwise XOR un registro (S) con el inmediato (I) y lo guarda en otro registro (T)          | 0011_10SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| LUI         | El valor inmediato (I) es shifteado a la izquierda 16 bits y guardado en el registro (T)   | 0011_11SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| SLTI        | If S < I => T = 1, else T = 0                                                              | 0010_10SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| BEQ         | Branchea a PC + I*4 si ambos registros (S y T) equalean                                    | 0001_00SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
| BNE         | Branchea a PC + I*4 si ambos registros (S y T) no equalean                                 | 0001_01SS_SSST_TTTT_IIII_IIII_IIII_IIII |         |
  
*** Tipo J

| Instruccion | Descripcion                                                                                                          | Codigo                                  | Señales |
|-------------+----------------------------------------------------------------------------------------------------------------------+-----------------------------------------+---------|
| J           | PC = (PC & 0xF0000000) OR (I << 2)                                                                                   | 0000_10II_IIII_IIII_IIII_IIII_IIII_IIII |         |
| JAL         | Jumpea a la direccion calculada [PC = (PC & 0xF0000000) OR (I << 2)] y storea la direccion de retorno en RA = PC + 4 | 0000_11II_IIII_IIII_IIII_IIII_IIII_IIII |         |
** Señales de control
*** EX

    - ALU [4bits]
      + 0000 -> ADD
      + 0001 -> SUB
      + 0010 -> AND
      + 0011 -> OR
      + 0100 -> XOR
      + 0101 -> NOR
      + 0110 -> SRL
      + 0111 -> SRA
      + 1000 -> SLT
    - B/I

*** MEM
    
    - RE
    - WE
    - DATA_SIZE [2bits]
      + 00 -> byte
      + 01 -> half-word
      + 10 -> word
      + 11 -> NO!
    - S/U

*** WB

    - DESTINO [5bits]
    - MEM/ALU
    - REG_WE
   


      



